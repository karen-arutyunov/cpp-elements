/*
 * product   : Elements - useful abstractions library.
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : GNU GPL v2; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NAMESPACE1_NAMESPACE2_RECORD__429145051_
#define _NAMESPACE1_NAMESPACE2_RECORD__429145051_

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace Namespace1
{
  namespace Namespace2
  {
//
// Record class declaration
//
    class Record: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      Record(El::MySQL::Result*)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong id() const
       throw(Exception, El::Exception);

      El::MySQL::String url() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime created() const
       throw(Exception, El::Exception);

      El::MySQL::String creator_type() const
       throw(Exception, El::Exception);

      El::MySQL::String creator_name() const
       throw(Exception, El::Exception);

      El::MySQL::Double activity() const
       throw(Exception, El::Exception);

      El::MySQL::Float density() const
       throw(Exception, El::Exception);

      El::MySQL::Double rate() const
       throw(Exception, El::Exception);

      El::MySQL::Bit flags() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort start_year() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime timeX() const
       throw(Exception, El::Exception);

      El::MySQL::String rgb() const
       throw(Exception, El::Exception);

      El::MySQL::String comment() const
       throw(Exception, El::Exception);

    };

//
// Record class definition
//
    inline
    Record::Record(El::MySQL::Result* result)
      throw(Exception, El::Exception)
        : Row(result)
    {
      if(result->num_fields() != 13)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected number of fields "
             << result->num_fields() << " instead of 13";

        throw Exception(ostr.str());
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 8 for field id";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 33)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 33 for field id";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "id"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of id for field id";

        throw Exception(ostr.str());
      }

      type = (*result)[1].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 253 for field url";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 1)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 1 for field url";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "url"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of url for field url";

        throw Exception(ostr.str());
      }

      type = (*result)[2].type;

      if(type != 7)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 7 for field created";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[2].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 161)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 161 for field created";

        throw Exception(ostr.str());
      }

      name = (*result)[2].name;

      if(strcmp(name, "created"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of created for field created";

        throw Exception(ostr.str());
      }

      type = (*result)[3].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 254 for field creator_type";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[3].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 1)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 1 for field creator_type";

        throw Exception(ostr.str());
      }

      name = (*result)[3].name;

      if(strcmp(name, "creator_type"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of creator_type for field creator_type";

        throw Exception(ostr.str());
      }

      type = (*result)[4].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 253 for field creator_name";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[4].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 1)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 1 for field creator_name";

        throw Exception(ostr.str());
      }

      name = (*result)[4].name;

      if(strcmp(name, "creator_name"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of creator_name for field creator_name";

        throw Exception(ostr.str());
      }

      type = (*result)[5].type;

      if(type != 5)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 5 for field activity";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[5].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 1)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 1 for field activity";

        throw Exception(ostr.str());
      }

      name = (*result)[5].name;

      if(strcmp(name, "activity"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of activity for field activity";

        throw Exception(ostr.str());
      }

      type = (*result)[6].type;

      if(type != 4)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 4 for field density";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[6].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 0)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 0 for field density";

        throw Exception(ostr.str());
      }

      name = (*result)[6].name;

      if(strcmp(name, "density"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of density for field density";

        throw Exception(ostr.str());
      }

      type = (*result)[7].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 246 for field rate";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[7].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 0)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 0 for field rate";

        throw Exception(ostr.str());
      }

      name = (*result)[7].name;

      if(strcmp(name, "rate"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of rate for field rate";

        throw Exception(ostr.str());
      }

      type = (*result)[8].type;

      if(type != 16)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 16 for field flags";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[8].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 0)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 0 for field flags";

        throw Exception(ostr.str());
      }

      name = (*result)[8].name;

      if(strcmp(name, "flags"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of flags for field flags";

        throw Exception(ostr.str());
      }

      type = (*result)[9].type;

      if(type != 13)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 13 for field start_year";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[9].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 32)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 32 for field start_year";

        throw Exception(ostr.str());
      }

      name = (*result)[9].name;

      if(strcmp(name, "start_year"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of start_year for field start_year";

        throw Exception(ostr.str());
      }

      type = (*result)[10].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 12 for field timeX";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[10].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 128)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 128 for field timeX";

        throw Exception(ostr.str());
      }

      name = (*result)[10].name;

      if(strcmp(name, "timeX"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of timeX for field timeX";

        throw Exception(ostr.str());
      }

      type = (*result)[11].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 254 for field rgb";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[11].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 0)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 0 for field rgb";

        throw Exception(ostr.str());
      }

      name = (*result)[11].name;

      if(strcmp(name, "rgb"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of rgb for field rgb";

        throw Exception(ostr.str());
      }

      type = (*result)[12].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected type " << type
             << " instead of 252 for field comment";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[12].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 0)
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected flags " << flags
             << " instead of 0 for field comment";

        throw Exception(ostr.str());
      }

      name = (*result)[12].name;

      if(strcmp(name, "comment"))
      {
        std::ostringstream ostr;
        ostr << "Record::Record: unexpected name " << name
             << " instead of comment for field comment";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    Record::id() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::id: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::id: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::id: failed to convert 'id' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    Record::url() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::url: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::url: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    Record::created() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::created: row_ is 0");
      }

      if(2 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::created: unexpected index 2 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[2] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[2], lengths[2]);

      return tmp;
    }

    inline
    El::MySQL::String
    Record::creator_type() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::creator_type: row_ is 0");
      }

      if(3 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::creator_type: unexpected index 3 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[3] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[3], lengths[3]);

      return tmp;
    }

    inline
    El::MySQL::String
    Record::creator_name() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::creator_name: row_ is 0");
      }

      if(4 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::creator_name: unexpected index 4 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[4] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[4], lengths[4]);

      return tmp;
    }

    inline
    El::MySQL::Double
    Record::activity() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::activity: row_ is 0");
      }

      if(5 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::activity: unexpected index 5 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[5] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[5], lengths[5]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::activity: failed to convert 'activity' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Float
    Record::density() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::density: row_ is 0");
      }

      if(6 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::density: unexpected index 6 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      float value = 0;
      bool is_null = row_[6] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[6], lengths[6]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::density: failed to convert 'density' field data"
            " to float";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Float(is_null, value);
    }

    inline
    El::MySQL::Double
    Record::rate() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::rate: row_ is 0");
      }

      if(7 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::rate: unexpected index 7 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[7] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[7], lengths[7]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::rate: failed to convert 'rate' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Bit
    Record::flags() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::flags: row_ is 0");
      }

      if(8 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::flags: unexpected index 8 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned char value = 0;
      bool is_null = row_[8] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[8], lengths[8]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::flags: failed to convert 'flags' field data"
            " to unsigned char";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Bit(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    Record::start_year() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::start_year: row_ is 0");
      }

      if(9 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::start_year: unexpected index 9 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[9] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[9], lengths[9]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record::start_year: failed to convert 'start_year' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::DateTime
    Record::timeX() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::timeX: row_ is 0");
      }

      if(10 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::timeX: unexpected index 10 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[10] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[10], lengths[10]);

      return tmp;
    }

    inline
    El::MySQL::String
    Record::rgb() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::rgb: row_ is 0");
      }

      if(11 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::rgb: unexpected index 11 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[11] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[11], lengths[11]);

      return tmp;
    }

    inline
    El::MySQL::String
    Record::comment() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record::comment: row_ is 0");
      }

      if(12 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record::comment: unexpected index 12 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[12] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[12], lengths[12]);

      return tmp;
    }

  }
}

namespace Namespace1
{
  namespace Namespace2
  {
//
// Record2 class declaration
//
    class Record2: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      Record2(El::MySQL::Result*)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong id() const
       throw(Exception, El::Exception);

      El::MySQL::String url() const
       throw(Exception, El::Exception);

    };

//
// Record2 class definition
//
    inline
    Record2::Record2(El::MySQL::Result* result)
      throw(Exception, El::Exception)
        : Row(result)
    {
      if(result->num_fields() != 2)
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected number of fields "
             << result->num_fields() << " instead of 2";

        throw Exception(ostr.str());
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected type " << type
             << " instead of 8 for field id";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 33)
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected flags " << flags
             << " instead of 33 for field id";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "id"))
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected name " << name
             << " instead of id for field id";

        throw Exception(ostr.str());
      }

      type = (*result)[1].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected type " << type
             << " instead of 253 for field url";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (NOT_NULL_FLAG|UNSIGNED_FLAG|BINARY_FLAG);

      if(flags != 1)
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected flags " << flags
             << " instead of 1 for field url";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "url"))
      {
        std::ostringstream ostr;
        ostr << "Record2::Record2: unexpected name " << name
             << " instead of url for field url";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    Record2::id() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record2::id: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record2::id: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "Record2::id: failed to convert 'id' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    Record2::url() const
      throw(Exception, El::Exception)
    {
      if(row_ == 0)
      {
        throw Exception("Record2::url: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "Record2::url: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

  }
}

#endif // _NAMESPACE1_NAMESPACE2_RECORD__429145051_
